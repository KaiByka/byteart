<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Quantum: Superposition & Entanglement</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #080808;
            font-family: 'Courier New', monospace;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            pointer-events: none;
            mix-blend-mode: exclusion;
        }

        h1 {
            margin: 0;
            font-size: 16px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .sub {
            font-size: 10px;
            opacity: 0.7;
            margin-top: 4px;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h1>Quantum Mechanics</h1>
        <div class="sub">Observation collapses the wave function</div>
    </div>
    <canvas id="c"></canvas>
    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');

        let width, height;
        let qubits = [];
        const numQubits = 12;

        let mouseX = -1000, mouseY = -1000;

        // 3D Cube vertices
        const cubePoints = [
            [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
            [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
        ];
        // Edges connecting vertices
        const cubeEdges = [
            [0, 1], [1, 2], [2, 3], [3, 0], // Front face
            [4, 5], [5, 6], [6, 7], [7, 4], // Back face
            [0, 4], [1, 5], [2, 6], [3, 7]  // Connecting lines
        ];

        class Qubit {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.z = 0;
                this.state = 'superposition'; // 'superposition', '0', '1'
                this.targetState = null; // 0 or 1

                this.rotX = Math.random() * Math.PI;
                this.rotY = Math.random() * Math.PI;
                this.rotVelX = (Math.random() - 0.5) * 0.05;
                this.rotVelY = (Math.random() - 0.5) * 0.05;

                this.entangled = null; // Partner qubit
                this.decoherenceTimer = 0; // Time before returning to superposition

                // Float animation
                this.floatOffset = Math.random() * Math.PI * 2;
            }

            measure(forcedVal = null) {
                if (this.state !== 'superposition') {
                    this.decoherenceTimer = 100; // Reset timer if already measured
                    return;
                }

                this.state = 'collapsed';
                this.targetState = (forcedVal !== null) ? forcedVal : (Math.random() > 0.5 ? 1 : 0);
                this.decoherenceTimer = 100; // Frames until decoherence

                // Trigger entangled partner
                if (this.entangled && this.entangled.state === 'superposition') {
                    // Entanglement correlation: Opposite spin? Or same? Let's say opposite.
                    this.entangled.measure(this.targetState === 1 ? 0 : 1);
                }
            }

            update() {
                // Rotation
                this.rotX += this.rotVelX;
                this.rotY += this.rotVelY;

                // Floating
                this.y += Math.sin(Date.now() * 0.001 + this.floatOffset) * 0.2;

                // Measurement Logic
                const dx = this.x - mouseX;
                const dy = this.y - mouseY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 150) {
                    this.measure();
                } else if (this.state !== 'superposition') {
                    // Decoherence: Return to chaos over time
                    this.decoherenceTimer--;
                    if (this.decoherenceTimer <= 0) {
                        this.state = 'superposition';
                        this.targetState = null;
                    }
                }
            }

            drawShape(ctx, scale, jitter, color, alpha) {
                ctx.strokeStyle = `rgba(${color}, ${alpha})`;
                ctx.lineWidth = 1.5;

                const projected = cubePoints.map(p => {
                    // Rotate
                    let px = p[0], py = p[1], pz = p[2];

                    // X-Rot
                    let y1 = py * Math.cos(this.rotX) - pz * Math.sin(this.rotX);
                    let z1 = py * Math.sin(this.rotX) + pz * Math.cos(this.rotX);
                    py = y1; pz = z1;

                    // Y-Rot
                    let x1 = px * Math.cos(this.rotY) - pz * Math.sin(this.rotY);
                    z1 = px * Math.sin(this.rotY) + pz * Math.cos(this.rotY);
                    px = x1; pz = z1;

                    // Project (Perspective)
                    const fov = 300;
                    const scaleFactor = fov / (fov + pz + 4); // +4 moves it back

                    // Apply Jitter if superposition
                    const jx = (Math.random() - 0.5) * jitter;
                    const jy = (Math.random() - 0.5) * jitter;

                    return [
                        this.x + px * scale * scaleFactor + jx,
                        this.y + py * scale * scaleFactor + jy
                    ];
                });

                ctx.beginPath();
                cubeEdges.forEach(edge => {
                    const p1 = projected[edge[0]];
                    const p2 = projected[edge[1]];
                    ctx.moveTo(p1[0], p1[1]);
                    ctx.lineTo(p2[0], p2[1]);
                });
                ctx.stroke();
            }

            draw() {
                if (this.state === 'superposition') {
                    // Draw multiple "Ghosts"
                    for (let i = 0; i < 4; i++) {
                        this.drawShape(ctx, 40, 15, '100, 100, 255', 0.15); // Deep Blue/Purple
                    }
                } else {
                    // Collapsed: Solid, Sharp
                    const color = this.targetState === 1 ? '255, 0, 100' : '0, 255, 255'; // Pink vs Cyan
                    this.drawShape(ctx, 40, 0, color, 1); // Solid, no jitter

                    // Label
                    ctx.fillStyle = `rgb(${color})`;
                    ctx.font = '12px monospace';
                    ctx.fillText(this.targetState === 1 ? "|1⟩" : "|0⟩", this.x + 30, this.y - 30);
                }

                // Draw Entanglement Line
                if (this.entangled) {
                    // Draw line to partner
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.entangled.x, this.entangled.y);
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }

        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;

            qubits = [];

            // Create pairs
            for (let i = 0; i < numQubits; i += 2) {
                // Random positions but kept somewhat on screen
                const q1 = new Qubit(Math.random() * (width - 100) + 50, Math.random() * (height - 100) + 50);
                const q2 = new Qubit(Math.random() * (width - 100) + 50, Math.random() * (height - 100) + 50);

                // Entangle them
                q1.entangled = q2;
                q2.entangled = q1;

                qubits.push(q1, q2);
            }
        }

        function animate() {
            ctx.fillStyle = '#080808';
            ctx.fillRect(0, 0, width, height);

            qubits.forEach(q => {
                q.update();
                q.draw();
            });

            reqId = requestAnimationFrame(animate);
        }

        let reqId;
        document.addEventListener("visibilitychange", () => {
            if (document.hidden) {
                if (reqId) cancelAnimationFrame(reqId);
            } else {
                animate();
            }
        });

        window.addEventListener('resize', init);
        window.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        window.addEventListener('touchmove', e => {
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
            e.preventDefault();
        }, { passive: false });

        init();
        animate();
    </script>
</body>

</html>